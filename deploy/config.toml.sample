# ============================================================================
# USB Enforcer Configuration
# ============================================================================
#
# SECURITY NOTE: allow_plaintext_write_with_scanning option
# ----------------------------------------------------------
# By default, unencrypted USB drives are mounted read-only for maximum 
# security. However, if you enable content_scanning (DLP), you can optionally
# allow write access to unencrypted drives with allow_plaintext_write_with_scanning.
#
# When enabled:
#   - Unencrypted USB drives are mounted read-write with FUSE overlay
#   - All writes are scanned for sensitive data (credit cards, SSNs, secrets)
#   - Prohibited content is blocked before writing to the drive
#   - Provides data loss prevention without sacrificing usability
#
# Requirements:
#   - content_scanning.enabled must be true
#   - Only works when content scanning is available
#   - If scanning unavailable, drive will mount read-only as fallback
#
# ============================================================================

# ============================================================================
# BASIC ENFORCEMENT
# ============================================================================
enforce_on_usb_only = true              # Only enforce on USB devices
allow_luks1_readonly = true             # Allow LUKS1 encrypted USB in read-only mode
allow_plaintext_write_with_scanning = true   # Require content scanning for write access on unencrypted drives
notification_enabled = true             # Show desktop notifications
min_passphrase_length = 12              # Minimum password length for encryption
exempted_groups = []                    # Groups exempt from enforcement (full bypass; prefer empty when using DLP scanning)

# Secret socket access (for passphrase handoff):
# The UNIX socket at /run/usb-enforcer.sock is owned by root and group "plugdev" by default.
# Active desktop session users must be in that group (or set USB_EE_SOCKET_GROUP) to connect.
secret_token_ttl_seconds = 300          # One-time token TTL (seconds) for unlock/encrypt requests
secret_token_max = 128                  # Max number of outstanding tokens kept in memory

# ============================================================================
# MOUNT SECURITY
# ============================================================================
default_plain_mount_opts = ["nodev", "nosuid", "noexec", "ro"]    # Unencrypted USB (read-only)
default_encrypted_mount_opts = ["nodev", "nosuid", "rw"]          # Encrypted USB (read-write)
require_noexec_on_plain = true                                     # Block executables on unencrypted USB

# ============================================================================
# ENCRYPTION DEFAULTS
# ============================================================================
encryption_target_mode = "whole_disk"   # Options: "whole_disk", "partition"
filesystem_type = "exfat"               # Filesystem after encryption: "exfat", "ext4", "ntfs"

[kdf]
type = "argon2id"                       # Key derivation: argon2id (recommended)

[cipher]
type = "aes-xts-plain64"                # Encryption algorithm
key_size = 512                          # Key size in bits

# ============================================================================
# CONTENT SCANNING (Data Loss Prevention)
# ============================================================================
[content_scanning]
enabled = true                          # Enable DLP scanning (scans files for sensitive data)
enforce_on_encrypted_devices = true     # true: block everywhere | false: only block on unencrypted USB
action = "block"                        # Options: "block", "warn", "log_only"

# What to scan for (remove items to disable specific categories)
enabled_categories = ["financial", "personal", "authentication", "medical"]
    # financial:      Credit cards, bank accounts, SWIFT codes, IBANs
    # personal:       SSN, passport numbers, driver licenses, phone numbers
    # authentication: API keys, passwords, tokens, private keys
    # medical:        Medical record numbers, insurance IDs

# Performance limits
max_file_size_mb = 100                  # Max size to scan; set 0 for unlimited
oversize_action = "block"               # block | allow_unscanned (allow writes without scanning when limit is hit)
streaming_threshold_mb = 16             # Spill writes to temp file when size exceeds this (0 = always stream)
large_file_scan_mode = "sampled"        # sampled | full (full scans entire file contents)
scan_timeout_seconds = 30               # Maximum scan time per file
max_concurrent_scans = 2                # Parallel scanning threads

# Advanced scanning options
archive_scanning_enabled = true         # Scan inside ZIP, TAR, 7Z, RAR files
max_archive_depth = 5                   # Maximum nested archive levels
document_scanning_enabled = true        # Scan PDF, DOCX, XLSX, PPTX, ODT files
ngram_analysis_enabled = true           # Machine learning pattern detection
cache_enabled = true                    # Cache scan results for speed
cache_max_size_mb = 100                 # Cache size limit

# ============================================================================
# CUSTOM PATTERNS (Optional - define your own sensitive data patterns)
# ============================================================================
# [[content_scanning.custom_patterns]]
# name = "internal_employee_id"
# description = "Company employee ID format"
# category = "personal"
# regex = "EMP-\\d{6}"
